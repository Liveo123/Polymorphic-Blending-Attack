#!/usr/bin/env python2
import struct
import math
import dpkt
import socket
from collections import Counter
from frequency import *

def substitute(attack_payload, substitution_table):
    # Using the substitution table you generated to encrypt attack payload
    # Note that you also need to generate a xor_table which will be used to decrypt the attack_payload
    # i.e. (encrypted attack payload) XOR (xor_table) = (original attack payload)
    b_attack_payload = bytearray(attack_payload)
    result = []
    xor_table = []
    # Based on your implementattion of substitution table, please prepare result and xor_table as output

    return (xor_table, result)

def getSubstitutionTable(artificial_payload, attack_payload):
    # You will need to generate a substitution table which can be used to encrypt the attack body by replacing the most frequent byte in attack body by the most frequent byte in artificial profile one by one

    # Note that the frequency for each byte is provided below in dictionay format. Please check frequency.py for more details
    artificial_frequency = frequency(artificial_payload)
    attack_frequency = frequency(attack_payload)

    sorted_artificial_frequency = sorting(artificial_frequency)
    sorted_attack_frequency = sorting(attack_frequency)

    # Your code here ...
    
    # Create an empty dictionary for the substitute table whose keys are 
    # characters and who values are list of tuples.  The list of tuples 
    # are characters with floats.
    sub_tbl = {}
    
    # Copy each character into the substitute table keys from the sorted 
    # attack frequency data structure.
    for char_tup in sorted_attack_frequency:
        sub_tbl[char_tup[0]] = []

    # For the first m characters, and first n, (Using m and n as a tuples here)
    for m, n in zip(sorted_attack_frequency, sorted_artificial_frequency):
        # Map attack characters to normal characters.
        sub_tbl[m[0]] = [n]     

    print("-----------------------")
    #sub_tbl['!'].append(('b',0))
   
    # Create counter for size of m to go to size of n
    m_plus_n_cnt = len(sub_tbl)

    # Create a temporary table of all of the character left from the 
    # artificial table
    chars_left =[]

    for cnt in range(m_plus_n_cnt, len(sorted_artificial_frequency)):
        chars_left.append(sorted_artificial_frequency[cnt])
    
  
    # For each of the m+nth characters in the artificial table:
    for char_in_art in chars_left:
        print(char_in_art)
        highest_ratio = 0       # This will hold the highest ratio after loop through

        # For each of the attack characters find the highest ratio where:
        for char_in_att in sorted_attack_frequency:
            # Add up all of the frequencies for the attack char in the sub table

#            # The ratio is the character over it and the sum 
#            # of all its mapped characters ratios
             for char_in_att_char_list in sub_tbl[char_in_art]:
                 if char_in_att_char_list[1]/
        # Assign m+n to the highest of the ratios found
    print("sub_tbl = ")
    print(sub_tbl)



    # You may implement substitution table in your way. Just make sure it can be used in substitute(attack_payload, subsitution_table)
    return substitution_table


def getAttackBodyPayload(path):
    f = open(path)
    pcap = dpkt.pcap.Reader(f)
    for ts, buf in pcap:
        eth = dpkt.ethernet.Ethernet(buf)
        ip = eth.data
        if socket.inet_ntoa(ip.dst) == "192.150.11.111": # TASK: Add in the destination address for your attack payload in quotes
            tcp = ip.data
            if tcp.data == "":
                continue
            return tcp.data.rstrip()

def getArtificialPayload(path):
    f = open(path)
    pcap = dpkt.pcap.Reader(f)
    for ts, buf in pcap:
        eth = dpkt.ethernet.Ethernet(buf)
        ip = eth.data
        tcp = ip.data
        if tcp.sport == 80 and len(tcp.data) > 0: #TASK: MODIFY THE PORT NUMBERS FOR IRC TRAFFIC (Similar to what you did in read_pcap.py)
            return tcp.data
